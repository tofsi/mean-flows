import math
import jax
import jax.numpy as jnp


# Used to demo generative flow models
# Adapted from https://github.com/MurrellGroup/Flowfusion.jl/blob/main/src/Flowfusion.jl
# Define a cat - from https://www.geogebra.org/m/pH8wD3rW
cat_shape = lambda t: jnp.array(
    (
        -(721 * jnp.sin(t)) / 4
        + 196 / 3 * jnp.sin(2 * t)
        - 86 / 3 * jnp.sin(3 * t)
        - 131 / 2 * jnp.sin(4 * t)
        + 477 / 14 * jnp.sin(5 * t)
        + 27 * jnp.sin(6 * t)
        - 29 / 2 * jnp.sin(7 * t)
        + 68 / 5 * jnp.sin(8 * t)
        + 1 / 10 * jnp.sin(9 * t)
        + 23 / 4 * jnp.sin(10 * t)
        - 19 / 2 * jnp.sin(12 * t)
        - 85 / 21 * jnp.sin(13 * t)
        + 2 / 3 * jnp.sin(14 * t)
        + 27 / 5 * jnp.sin(15 * t)
        + 7 / 4 * jnp.sin(16 * t)
        + 17 / 9 * jnp.sin(17 * t)
        - 4 * jnp.sin(18 * t)
        - 1 / 2 * jnp.sin(19 * t)
        + 1 / 6 * jnp.sin(20 * t)
        + 6 / 7 * jnp.sin(21 * t)
        - 1 / 8 * jnp.sin(22 * t)
        + 1 / 3 * jnp.sin(23 * t)
        + 3 / 2 * jnp.sin(24 * t)
        + 13 / 5 * jnp.sin(25 * t)
        + jnp.sin(26 * t)
        - 2 * jnp.sin(27 * t)
        + 3 / 5 * jnp.sin(28 * t)
        - 1 / 5 * jnp.sin(29 * t)
        + 1 / 5 * jnp.sin(30 * t)
        + (2337 * jnp.cos(t)) / 8
        - 43 / 5 * jnp.cos(2 * t)
        + 322 / 5 * jnp.cos(3 * t)
        - 117 / 5 * jnp.cos(4 * t)
        - 26 / 5 * jnp.cos(5 * t)
        - 23 / 3 * jnp.cos(6 * t)
        + 143 / 4 * jnp.cos(7 * t)
        - 11 / 4 * jnp.cos(8 * t)
        - 31 / 3 * jnp.cos(9 * t)
        - 13 / 4 * jnp.cos(10 * t)
        - 9 / 2 * jnp.cos(11 * t)
        + 41 / 20 * jnp.cos(12 * t)
        + 8 * jnp.cos(13 * t)
        + 2 / 3 * jnp.cos(14 * t)
        + 6 * jnp.cos(15 * t)
        + 17 / 4 * jnp.cos(16 * t)
        - 3 / 2 * jnp.cos(17 * t)
        - 29 / 10 * jnp.cos(18 * t)
        + 11 / 6 * jnp.cos(19 * t)
        + 12 / 5 * jnp.cos(20 * t)
        + 3 / 2 * jnp.cos(21 * t)
        + 11 / 12 * jnp.cos(22 * t)
        - 4 / 5 * jnp.cos(23 * t)
        + jnp.cos(24 * t)
        + 17 / 8 * jnp.cos(25 * t)
        - 7 / 2 * jnp.cos(26 * t)
        - 5 / 6 * jnp.cos(27 * t)
        - 11 / 10 * jnp.cos(28 * t)
        + 1 / 2 * jnp.cos(29 * t)
        - 1 / 5 * jnp.cos(30 * t),
        -(637 * jnp.sin(t)) / 2
        - 188 / 5 * jnp.sin(2 * t)
        - 11 / 7 * jnp.sin(3 * t)
        - 12 / 5 * jnp.sin(4 * t)
        + 11 / 3 * jnp.sin(5 * t)
        - 37 / 4 * jnp.sin(6 * t)
        + 8 / 3 * jnp.sin(7 * t)
        + 65 / 6 * jnp.sin(8 * t)
        - 32 / 5 * jnp.sin(9 * t)
        - 41 / 4 * jnp.sin(10 * t)
        - 38 / 3 * jnp.sin(11 * t)
        - 47 / 8 * jnp.sin(12 * t)
        + 5 / 4 * jnp.sin(13 * t)
        - 41 / 7 * jnp.sin(14 * t)
        - 7 / 3 * jnp.sin(15 * t)
        - 13 / 7 * jnp.sin(16 * t)
        + 17 / 4 * jnp.sin(17 * t)
        - 9 / 4 * jnp.sin(18 * t)
        + 8 / 9 * jnp.sin(19 * t)
        + 3 / 5 * jnp.sin(20 * t)
        - 2 / 5 * jnp.sin(21 * t)
        + 4 / 3 * jnp.sin(22 * t)
        + 1 / 3 * jnp.sin(23 * t)
        + 3 / 5 * jnp.sin(24 * t)
        - 3 / 5 * jnp.sin(25 * t)
        + 6 / 5 * jnp.sin(26 * t)
        - 1 / 5 * jnp.sin(27 * t)
        + 10 / 9 * jnp.sin(28 * t)
        + 1 / 3 * jnp.sin(29 * t)
        - 3 / 4 * jnp.sin(30 * t)
        - (125 * jnp.cos(t)) / 2
        - 521 / 9 * jnp.cos(2 * t)
        - 359 / 3 * jnp.cos(3 * t)
        + 47 / 3 * jnp.cos(4 * t)
        - 33 / 2 * jnp.cos(5 * t)
        - 5 / 4 * jnp.cos(6 * t)
        + 31 / 8 * jnp.cos(7 * t)
        + 9 / 10 * jnp.cos(8 * t)
        - 119 / 4 * jnp.cos(9 * t)
        - 17 / 2 * jnp.cos(10 * t)
        + 22 / 3 * jnp.cos(11 * t)
        + 15 / 4 * jnp.cos(12 * t)
        - 5 / 2 * jnp.cos(13 * t)
        + 19 / 6 * jnp.cos(14 * t)
        + 7 / 4 * jnp.cos(15 * t)
        + 31 / 4 * jnp.cos(16 * t)
        - jnp.cos(17 * t)
        + 11 / 10 * jnp.cos(18 * t)
        - 2 / 3 * jnp.cos(19 * t)
        + 13 / 3 * jnp.cos(20 * t)
        - 5 / 4 * jnp.cos(21 * t)
        + 2 / 3 * jnp.cos(22 * t)
        + 1 / 4 * jnp.cos(23 * t)
        + 5 / 6 * jnp.cos(24 * t)
        + 3 / 4 * jnp.cos(26 * t)
        - 1 / 2 * jnp.cos(27 * t)
        - 1 / 10 * jnp.cos(28 * t)
        - 1 / 3 * jnp.cos(29 * t)
        - 1 / 19 * jnp.cos(30 * t),
    )
)


def random_literal_cat(key, *dims, sigma=jnp.float32(0.05)):
    n = math.prod(dims)
    key_ang, key_noise = jax.random.split(key)

    angles = jax.random.uniform(
        key_ang, (n,), minval=0.0, maxval=2 * jnp.pi
    )  # U[0, 2Ï€)
    base = jax.vmap(lambda th: cat_shape(th) / 200.0)(angles)  # (n, 2)
    base = base.T.reshape((2, *dims))  # (2, dims...)
    noise = jax.random.normal(key_noise, (2, *dims)) * sigma
    return (base + noise).astype(sigma.dtype)
